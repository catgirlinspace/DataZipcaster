import datetime as dt
import uuid
from typing import cast

from data_zipcaster.constants import MODES
from data_zipcaster.models import main, splatnet
from data_zipcaster.transforms.splatnet_to_main.players import convert_player
from data_zipcaster.utils import base64_decode, color_from_percent_to_str


def generate_match_uuid(battle_id: str, namespace: uuid.UUID) -> str:
    """Generates a match UUID from a battle ID.

    Given a battle ID, this method will generate a match UUID. This is done
    according to stat.ink's documentation, which can be found
    `here <https://tinyurl.com/3atce4kw>`_. The UUID is generated using the
    ``uuid.uuid5`` method, which takes a namespace UUID and a name. The
    namespace UUID is provided by the user, and the name is the last 52
    characters of the battle ID. The last 52 characters of the battle ID are
    used since it contains the timestamp of the battle in the form
    ``YYYYMMDDTHHMMSS`` followed by a match uuid generated by Nintendo. This
    should ensure there are no collisions between match UUIDs.


    Args:
        battle_id (str): A (probably) unique ID for a battle. This is the
            ``id`` field of the ``vsHistoryDetail`` field of the response
            from a ``vsHistoryDetail`` query.
        namespace (uuid.UUID): The namespace UUID to use when generating the
            match UUID.

    Returns:
        str: The match UUID.
    """
    return str(uuid.uuid5(namespace, battle_id[-52:]))


def convert_mode(battle_id: str) -> main.ModeType:
    mode_idx = base64_decode(battle_id)[len("VsMode-") :]
    return cast(main.ModeType, MODES.get_mode_by_id(mode_idx)["key"])


def convert_rule(rule: splatnet.RuleType) -> main.RuleType:
    rule_remap: dict[splatnet.RuleType, main.RuleType] = {
        "TURF_WAR": "turf_war",
        "AREA": "splat_zones",
        "LOFT": "tower_control",
        "GOAL": "rainmaker",
        "CLAM": "clam_blitz",
        "TRICOLOR": "tricolor",
    }
    return rule_remap[rule]


def convert_stage(stage_id: str) -> str:
    return base64_decode(stage_id)[len("Stage-") :]


def convert_result(
    judgement: splatnet.ResultType,
) -> main.ResultType:
    result_remap: dict[splatnet.ResultType, main.ResultType] = {
        "WIN": "win",
        "LOSE": "lose",
        "DRAW": "draw",
        "EXEMPTED_LOSE": "exempted_lose",
        "DEEMED_LOSE": "deemed_lose",
    }
    return result_remap[judgement]


def convert_start_time(start_time: str) -> dt.datetime:
    return dt.datetime.strptime(start_time, "%Y-%m-%dT%H:%M:%SZ")


def convert_duration(duration: int) -> dt.timedelta:
    return dt.timedelta(seconds=duration)


def get_teams_data(
    vs_detail: splatnet.VsDetail,
) -> list[splatnet.Team]:
    return [
        vs_detail.vsHistoryDetail.myTeam,
        *vs_detail.vsHistoryDetail.otherTeams,
    ]


def convert_tricolor_role(
    role: splatnet.TricolorRoleType | None,
) -> main.TricolorRoleType | None:
    if role is None:
        return None

    remap: dict[splatnet.TricolorRoleType, main.TricolorRoleType] = {
        "DEFENSE": "defense",
        "ATTACK1": "attack1",
        "ATTACK2": "attack2",
    }
    return remap[role]


def convert_team_data(vs_detail: splatnet.VsDetail) -> list[main.Team]:
    teams = get_teams_data(vs_detail)
    out: list[main.Team] = []

    for team in teams:
        sub_out = main.Team(
            players=[
                convert_player(player, idx)
                for idx, player in enumerate(team.players)
            ],
            color=color_from_percent_to_str(team.color.model_dump()),
            order=team.order,
        )

        if team.result is not None:
            assert team.judgement is not None
            sub_out.result = main.TeamResult(
                paint_ratio=team.result.paintRatio,
                score=team.result.score,
                noroshi=team.result.noroshi,
                team_result=convert_result(team.judgement),
            )

        if team.festTeamName is not None:
            sub_out.splatfest = main.SplatfestTeam(
                team_name=team.festTeamName,
                synergy_bonus=team.festUniformBonusRate,
                synergy_name=team.festUniformName,
                tricolor_role=convert_tricolor_role(team.tricolorRole),
            )

        out.append(sub_out)
    return out


def convert_knockout(knockout: splatnet.KnockoutType) -> main.KnockoutType:
    knockout_remap: dict[splatnet.KnockoutType, main.KnockoutType] = {
        "WIN": "win",
        "LOSE": "lose",
        "NEITHER": "neither",
    }
    return knockout_remap[knockout]
