import datetime as dt
import uuid
from typing import Literal, cast
from urllib.parse import urlparse

from splatnet3_scraper.query import QueryResponse

from data_zipcaster.assets import GEAR_HASHES
from data_zipcaster.constants import MODES, NAMESPACES
from data_zipcaster.importers.splatnet.extractors.players import (
    extract_player_data,
)
from data_zipcaster.importers.splatnet.paths import common_paths, vs_modes_paths
from data_zipcaster.utils import base64_decode, color_from_percent_to_str


def generate_match_uuid(battle_id: str, namespace: uuid.UUID) -> str:
    """Generates a match UUID from a battle ID.

    Given a battle ID, this method will generate a match UUID. This is done
    according to stat.ink's documentation, which can be found
    `here <https://tinyurl.com/3atce4kw>`_. The UUID is generated using the
    ``uuid.uuid5`` method, which takes a namespace UUID and a name. The
    namespace UUID is provided by the user, and the name is the last 52
    characters of the battle ID. The last 52 characters of the battle ID are
    used since it contains the timestamp of the battle in the form
    ``YYYYMMDDTHHMMSS`` followed by a match uuid generated by Nintendo. This
    should ensure there are no collisions between match UUIDs.


    Args:
        battle_id (str): A (probably) unique ID for a battle. This is the
            ``id`` field of the ``vsHistoryDetail`` field of the response
            from a ``vsHistoryDetail`` query.
        namespace (uuid.UUID): The namespace UUID to use when generating the
            match UUID.

    Returns:
        str: The match UUID.
    """
    return str(uuid.uuid5(namespace, battle_id[-52:]))


def extract_mode(battle: QueryResponse) -> str:
    """Extracts and converts the mode from a battle response.

    Given a response from a ``vsHistoryDetail`` query, this method will extract
    the mode and convert it to a string. This is done via a lookup table, which
    is based on the base64 decoded ``id`` field of the ``vsMode`` field. The
    ``id`` field is a base64 encoded string, which is decoded and is of the form
    ``VsMode-<mode_id>``. The ``mode_id`` is then used to lookup the mode in the
    ``mode_idx_remap`` table. Below are the values of the ``mode_id`` and their
    corresponding modes:

    - ``1``: ``regular`` (regular battle)
    - ``2``: ``bankara_challenge`` (anarchy series battle)
    - ``3``: ``xbattle`` (x battle)
    - ``5``: ``private`` (private battle)
    - ``51``: ``bankara-open`` (anarchy open battle)
    - ``6``: ``splatfest_open`` (splatfest open battle)
    - ``7``: ``splatfest_challenge`` (splatfest pro battle)
    - ``8``: ``splatfest_open`` (splatfest tricolor battle)

    Args:
        battle (QueryResponse): Path from the base response:
            ``vsHistoryDetail``. This is the response from a
            ``vsHistoryDetail`` query from the ``splatnet3_scraper``
            package.

    Returns:
        str: The mode of the battle. This is not to be confused with the
            rule of the battle, which is what is commonly referred to as
            the mode. This is confusing, but is the terminology used by
            SplatNet 3.
    """
    battle_id = battle[common_paths.MODE]
    mode_id = base64_decode(cast(str, battle_id))

    mode_idx = mode_id[len("VsMode-") :]

    return MODES.get_mode_by_id(mode_idx)["key"]


def extract_rule(
    battle: QueryResponse, path: str | tuple[str, ...] = common_paths.RULE
) -> str:
    """Extracts and converts the rule from a battle response.

    Given a response from a ``vsHistoryDetail`` query, this method will extract
    the rule and convert it to a string. This is done via a lookup table, which
    is based on the ``rule`` field of the ``vsRule`` field. Below are the values
    of the ``rule`` field and their corresponding rules:

    - ``turf_war``: ``nawabari`` (turf war)
    - ``splat_zones``: ``area`` (splat zones)
    - ``tower_control``: ``yagura`` (tower control)
    - ``rainmaker``: ``hoko`` (rainmaker)
    - ``clam_blitz``: ``asari`` (clam blitz)
    - ``tricolor``: ``tricolor`` (splatfest tricolor battle)

    Args:
        battle (QueryResponse): Path from the base response:
            ``vsHistoryDetail``. This is the response from a
            ``vsHistoryDetail`` query from the ``splatnet3_scraper``
            package.

    Returns:
        str: The rule of the battle. This is not to be confused with the mode of
            the battle, which is what the rule is commonly referred to as. This
            is confusing, but is the terminology used by SplatNet 3.
    """
    rule = cast(str, battle[path]).lower()
    rule_remap = {
        "turf_war": "turf_war",
        "area": "splat_zones",  # Splat Zones
        "loft": "tower_control",  # Tower Control
        "goal": "rainmaker",  # Rainmaker
        "clam": "clam_blitz",  # Clam Blitz
        "tricolor": "tricolor",
    }
    return rule_remap[rule]


def extract_stage(battle: QueryResponse) -> str:
    stage_id = cast(str, battle[common_paths.STAGE])
    stage = base64_decode(stage_id)[len("VsStage-") :]
    return stage


def extract_result(battle: QueryResponse) -> str:
    judgement = cast(str, battle[common_paths.JUDGEMENT])
    return parse_result(judgement)


def parse_result(result: str) -> str:
    if result == "DEEMED_LOSE":
        return "lose"
    return result.lower()


def extract_start_time(battle: QueryResponse) -> float:
    start_time = cast(str, battle[common_paths.PLAYED_TIME])
    absolute_time = dt.datetime.strptime(start_time, "%Y-%m-%dT%H:%M:%SZ")
    epoch = dt.datetime.utcfromtimestamp(0)
    return (absolute_time - epoch).total_seconds()


def get_teams_data(
    battle: QueryResponse,
) -> tuple[
    list[QueryResponse],
    tuple[Literal["our"], Literal["their"], Literal["third"]],
]:
    teams = [
        battle[common_paths.MY_TEAM],
        *battle[common_paths.OTHER_TEAMS],
    ]
    out_keys = ("our", "their", "third")
    return teams, out_keys


def extract_team_data(
    battle: QueryResponse,
) -> dict:
    teams, team_name_keys = get_teams_data(battle)
    out = {}
    for i, team in enumerate(teams):
        team_data = []
        for idx, player in enumerate(team["players"]):
            player = cast(QueryResponse, player)
            team_data.append(extract_player_data(player, idx))
        key = "%s_team_players" % team_name_keys[i]
        color_str = color_from_percent_to_str(team["color"])
        color_key = "%s_team_color" % team_name_keys[i]
        result_key = "%s_team_result" % team_name_keys[i]
        out[key] = team_data
        out[color_key] = color_str
        try:
            out[result_key] = team["result"].data
        except AttributeError:
            pass
    return out


def extract_knockout(battle: QueryResponse) -> bool | None:
    return cast(bool | None, battle.get(vs_modes_paths.KNOCKOUT))


def extract_medals(battle: QueryResponse) -> list[dict]:
    return cast(list[dict], battle[common_paths.MEDALS].data)


def extract_duration(battle: QueryResponse) -> int:
    return cast(int, battle[common_paths.DURATION])


def extract_id(battle: QueryResponse) -> str:
    return cast(str, battle[common_paths.ID])
