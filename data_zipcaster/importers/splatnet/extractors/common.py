import datetime as dt
import uuid
from typing import Literal, TypeGuard, cast

from splatnet3_scraper.query import QueryResponse

from data_zipcaster.constants import MODES
from data_zipcaster.importers.splatnet.extractors.players import (
    extract_player_data,
)
from data_zipcaster.importers.splatnet.paths import common_paths, vs_modes_paths
from data_zipcaster.schemas.players import PlayerDict
from data_zipcaster.schemas.typing import (
    KnockoutType,
    ModeType,
    ResultType,
    RuleType,
)
from data_zipcaster.schemas.vs_modes import MedalDict, TeamDict
from data_zipcaster.utils import base64_decode, color_from_percent_to_str


def generate_match_uuid(battle_id: str, namespace: uuid.UUID) -> str:
    """Generates a match UUID from a battle ID.

    Given a battle ID, this method will generate a match UUID. This is done
    according to stat.ink's documentation, which can be found
    `here <https://tinyurl.com/3atce4kw>`_. The UUID is generated using the
    ``uuid.uuid5`` method, which takes a namespace UUID and a name. The
    namespace UUID is provided by the user, and the name is the last 52
    characters of the battle ID. The last 52 characters of the battle ID are
    used since it contains the timestamp of the battle in the form
    ``YYYYMMDDTHHMMSS`` followed by a match uuid generated by Nintendo. This
    should ensure there are no collisions between match UUIDs.


    Args:
        battle_id (str): A (probably) unique ID for a battle. This is the
            ``id`` field of the ``vsHistoryDetail`` field of the response
            from a ``vsHistoryDetail`` query.
        namespace (uuid.UUID): The namespace UUID to use when generating the
            match UUID.

    Returns:
        str: The match UUID.
    """
    return str(uuid.uuid5(namespace, battle_id[-52:]))


def extract_mode(battle: QueryResponse) -> ModeType:
    """Extracts and converts the mode from a battle response.

    Given a response from a ``vsHistoryDetail`` query, this method will extract
    the mode and convert it to a string. This is done via a lookup table, which
    is based on the base64 decoded ``id`` field of the ``vsMode`` field. The
    ``id`` field is a base64 encoded string, which is decoded and is of the form
    ``VsMode-<mode_id>``. The ``mode_id`` is then used to lookup the mode in the
    ``mode_idx_remap`` table. Below are the values of the ``mode_id`` and their
    corresponding modes:

    - ``1``: ``regular`` (regular battle)
    - ``2``: ``bankara_challenge`` (anarchy series battle)
    - ``3``: ``xbattle`` (x battle)
    - ``4``: ``league`` (challenge battle)
    - ``5``: ``private`` (private battle)
    - ``51``: ``bankara_open`` (anarchy open battle)
    - ``6``: ``splatfest_open`` (splatfest open battle)
    - ``7``: ``splatfest_challenge`` (splatfest pro battle)
    - ``8``: ``splatfest_open`` (splatfest tricolor battle)

    Args:
        battle (QueryResponse): Path from the base response:
            ``vsHistoryDetail``. This is the response from a
            ``vsHistoryDetail`` query from the ``splatnet3_scraper``
            package.

    Returns:
        ModeType: The mode of the battle. This is not to be confused with the
            rule of the battle, which is what is commonly referred to as the
            mode. This is confusing, but is the terminology used by SplatNet 3.
            One of ``regular``, ``bankara_challenge``, ``xbattle``, ``league``,
            ``private``, ``bankara-open``, ``splatfest_open``,
            ``splatfest_challenge``, or ``splatfest_open``.
    """
    battle_id = battle[common_paths.MODE]
    mode_id = base64_decode(cast(str, battle_id))

    mode_idx = mode_id[len("VsMode-") :]

    return cast(ModeType, MODES.get_mode_by_id(mode_idx)["key"])


def extract_rule(
    battle: QueryResponse, path: str | tuple[str, ...] = common_paths.RULE
) -> RuleType:
    """Extracts and converts the rule from a battle response.

    Given a response from a ``vsHistoryDetail`` query, this method will extract
    the rule and convert it to a string. This is done via a lookup table, which
    is based on the ``rule`` field of the ``vsRule`` field. Below are the values
    of the ``rule`` field and their corresponding rules:

    - ``turf_war``: ``nawabari`` (turf war)
    - ``splat_zones``: ``area`` (splat zones)
    - ``tower_control``: ``yagura`` (tower control)
    - ``rainmaker``: ``hoko`` (rainmaker)
    - ``clam_blitz``: ``asari`` (clam blitz)
    - ``tricolor``: ``tricolor`` (splatfest tricolor battle)

    Args:
        battle (QueryResponse): Path from the base response:
            ``vsHistoryDetail``. This is the response from a
            ``vsHistoryDetail`` query from the ``splatnet3_scraper``
            package.
        path (str | tuple[str, ...], optional): The path to the rule field.

    Returns:
        RuleType: The rule of the battle. This is not to be confused with the
            mode of the battle, which is what the rule is commonly referred to
            as. This is confusing, but is the terminology used by SplatNet 3.
            One of ``turf_war``, ``splat_zones``, ``tower_control``,
            ``rainmaker``, ``clam_blitz``, or ``tricolor``.
    """
    rule = cast(str, battle[path]).lower()
    rule_remap: dict[str, RuleType] = {
        "turf_war": "turf_war",
        "area": "splat_zones",  # Splat Zones
        "loft": "tower_control",  # Tower Control
        "goal": "rainmaker",  # Rainmaker
        "clam": "clam_blitz",  # Clam Blitz
        "tricolor": "tricolor",
    }
    return rule_remap[rule]


def extract_stage(battle: QueryResponse) -> str:
    """Extracts the stage from a battle response.

    Given a response from a ``vsHistoryDetail`` query, this method will extract
    the stage and convert it to a string. The stage is extracted from the
    path ``vsHistoryDetail`` -> ``stage`` -> ``id``. The ``id`` field is a
    base64 encoded string, which is decoded and is of the form
    ``VsStage-<stage_id>``. The ``stage_id`` is then returned.

    Args:
        battle (QueryResponse): The base battle response.

    Returns:
        str: The stage where the battle took place. This is the stage ID, not
            the stage name, to prevent language localization issues.
    """
    stage_id = cast(str, battle[common_paths.STAGE])
    stage = base64_decode(stage_id)[len("VsStage-") :]
    return stage


def extract_result(battle: QueryResponse) -> ResultType:
    """Extracts the result from a battle response.

    Given a response from a ``vsHistoryDetail`` query, this method will extract
    the result and convert it to a string. The result is extracted from the
    path ``vsHistoryDetail`` -> ``judgement``. This result is then parsed and
    forced to lowercase. The parsing essentially just converts the result of
    ``DEEMED_LOSE`` to ``lose``.

    Args:
        battle (QueryResponse): The base battle response.

    Returns:
        ResultType: The result of the battle. This is either ``win``, ``lose``,
            ``exempted_lose``, or ``draw``.
    """
    judgement = cast(str, battle[common_paths.JUDGEMENT])
    return parse_result(judgement)


def is_result_type(judgement: str) -> TypeGuard[ResultType]:
    """Type guard for ``ResultType``. Checks if the judgement is a valid result.

    Args:
        judgement (str): The judgement to check.

    Returns:
        TypeGuard[ResultType]: Whether or not the judgement is a valid result.
    """
    return judgement in ["win", "lose", "exempted_lose", "draw"]


def parse_result(judgement: str) -> ResultType:
    """Parses the result of a battle.

    This method parses the result of a battle and converts it to a string. The
    result is forced to lowercase. The parsing essentially just converts the
    result of ``DEEMED_LOSE`` to ``lose``.

    Args:
        judgement (str): The result of the battle.

    Raises:
        ValueError: If the judgement is not a valid result type.

    Returns:
        ResultType: The result of the battle. This is either ``win``, ``lose``,
            ``exempted_lose``, or ``draw``.
    """
    judgement = judgement.lower()
    if judgement == "deemed_lose":
        judgement = "lose"

    if is_result_type(judgement):
        return judgement
    else:
        raise ValueError(f"Unknown judgement: {judgement}")


def extract_start_time(battle: QueryResponse) -> float:
    """Extracts the start time of a battle.

    Given a response from a ``vsHistoryDetail`` query, this method will extract
    the start time of the battle and convert it to a float. The start time is
    extracted from the path ``vsHistoryDetail`` -> ``playedTime``. This is then
    converted to a ``datetime`` object, which is then converted to a float
    representing the number of seconds since the epoch.

    Args:
        battle (QueryResponse): The base battle response.

    Returns:
        float: The start time of the battle, in seconds since the epoch.
    """
    start_time = cast(str, battle[common_paths.PLAYED_TIME])
    absolute_time = dt.datetime.strptime(start_time, "%Y-%m-%dT%H:%M:%SZ")
    epoch = dt.datetime.utcfromtimestamp(0)
    return (absolute_time - epoch).total_seconds()


def get_teams_data(
    battle: QueryResponse,
) -> list[QueryResponse]:
    """Gets the data for all teams in a battle.

    Given a response from a ``vsHistoryDetail`` query, this method will extract
    the data for all teams in the battle. This includes the player data for
    each player on the team, as well as the team color and result. There will be
    either two or three teams in a battle, depending on the game mode. The order
    of the teams is as follows:

    - Player's team, at index 0
    - Enemy team, at index 1
    - If the game mode is ``tricolor``, there will be a third team at index 2.

    Args:
        battle (QueryResponse): The base battle response.

    Returns:
        list[QueryResponse]: The data for all teams in the battle, in the order
            of [``our_team``, ``their_team``, ``third_team``].
    """
    return [
        battle[common_paths.MY_TEAM],
        *battle[common_paths.OTHER_TEAMS],
    ]


def extract_team_data(
    battle: QueryResponse,
) -> list[TeamDict]:
    """Extracts the data for all teams in a battle.

    Given a response from a ``vsHistoryDetail`` query, this method will extract
    the data for all teams in the battle. This includes the player data for
    each player on the team, as well as the team color and result. There will be
    either two or three teams in a battle, depending on the game mode. The order
    of the teams is as follows:

    - Player's team, at index 0
    - Enemy team, at index 1
    - If the game mode is ``tricolor``, there will be a third team at index 2.

    Args:
        battle (QueryResponse): The base battle response.

    Returns:
        list[TeamDict]: The data for all teams in the battle, in the order of
            [``our_team``, ``their_team``, ``third_team``].
    """
    teams = get_teams_data(battle)
    out: list[TeamDict] = []

    for team in teams:
        players: list[PlayerDict] = []
        for idx, player in enumerate(team["players"]):
            player = cast(QueryResponse, player)
            players.append(extract_player_data(player, idx))

        color_str = color_from_percent_to_str(team["color"])
        sub_out = TeamDict(
            players=players,
            color=color_str,
        )
        try:
            sub_out["result"] = team["result"].data
        except AttributeError:
            pass
        out.append(sub_out)
    return out


def extract_knockout(battle: QueryResponse) -> KnockoutType:
    """Extracts the knockout status of a battle.

    Args:
        battle (QueryResponse): The base battle response.

    Returns:
        KnockoutType: The knockout status of the battle. This is either
            ``win``, ``lose``, ``neither``, or None.
    """
    return cast(KnockoutType, battle.get(vs_modes_paths.KNOCKOUT))


def extract_medals(battle: QueryResponse) -> list[MedalDict]:
    """Extracts the medals earned in a battle.

    Args:
        battle (QueryResponse): The base battle response.

    Returns:
        list[MedalDict]: The medals earned in the battle.
    """
    medal_data = cast(list[dict], battle[common_paths.MEDALS].data)
    out: list[MedalDict] = []
    for medal in medal_data:
        medal_name = cast(str, medal[common_paths.NAME])
        medal_rank = cast(Literal["GOLD", "SILVER"], medal[common_paths.RANK])
        out.append(MedalDict(name=medal_name, rank=medal_rank))
    return out


def extract_duration(battle: QueryResponse) -> int:
    """Extracts the duration of a battle.

    Args:
        battle (QueryResponse): The base battle response.

    Returns:
        int: The duration of the battle, in seconds.
    """
    return cast(int, battle[common_paths.DURATION])


def extract_id(battle: QueryResponse) -> str:
    """Extracts the ID of a battle.

    Args:
        battle (QueryResponse): The base battle response.

    Returns:
        str: The ID of the battle.
    """
    battle_id = cast(str, battle[common_paths.ID])
    return base64_decode(battle_id)
